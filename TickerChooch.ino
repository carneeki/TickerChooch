/*******************************************************************************
 * TickerChooch                                                                *
 *                                                                             *
 * Makes a stepper motor drive along a track for a preprogrammed distance with *
 * pauses for given times. Speed is set in configuration. Details are          *
 * displayed on an LCD panel.                                                  *
 *                                                                             *
 * By Adam Carmichael <carneeki@carneeki.net>                                  *
 * For Emma's Spare Room Machine Shop <missemmajade@gmail.com>                 *
 *                                                                             *
 ******************************************************************************/

#include <Stepper.h>
#include <limits.h>
#include "PCD8544.h"
//#include "PCD8544.cpp"

// TODO: Change all these values to suit

// pins 3,4,5,6,7 used for LCD screen
#define STEP_AP          8   // Stepper pin A+
#define STEP_AN          9   // Stepper pin A-
#define STEP_BP         10   // Stepper pin B+
#define STEP_BN         11   // Stepper pin B-
#define STEPS_PER_REV 2048   // Number of steps to make one complete revolution of
                             // the motor shaft

#define SPEED         1000   // Speed in mm per minute
#define DIST_PER_REV    62.5 // Distance travelled for 1 rev of stepper shaft

#define SW_LIMIT        11   // Limit switch pin is pulled HIGH when at limit
#define SW_DIR_FWD      12   // Forwards direction is pulled HIGH for forward
#define SW_DIR_REV      13   // Reverse direction is pulled HIGH for reverse
#define SW_START         1   // Start / stop push button

#define KNOB_DIST       A0   // Wiper for distance knob
#define KNOB_PAUSE      A1   // Wiper for pause knob
#define KNOB_SPEED      A2   // Wiper for speed knob
#define DIST_MAX      1500   // Maximum distance (mm)
#define DIST_INCR       20   // # of increments for distance
#define PAUSE_MAX       90   // Maximum pause time (seconds)
#define PAUSE_INCR       1   // # of increments for pause time

#define STATE_INIT       1   // initialisation state - not much really happens
#define STATE_DATA       2   // data entry and ready state
#define STATE_RUN        3   // run state - carriage moves
#define STATE_PAUSE      4   // pause state between movements

// motor object
Stepper motor(STEPS_PER_REV, STEP_AP, STEP_AN, STEP_BP, STEP_BN);

// data entered vars
int distance       = 0;  // configured distance to travel (in mm)
int pauseTime      = 0;  // configured pause time (in seconds)
int speed          = 0;  // configured speed (in mm / minute)
bool run           = false; // direction switch is not neutral
bool fwd           = true;  // fwd = true, rev = false

// chooch() cycle vars
int remainingSteps = 0;  // steps to complete in this chooch() cycle
int remainingDist  = 0;  // remaining distance in this chooch() cycle

// pause() cycle vars
int remainingTime  = 0;  //  remaining seconds in this pause() cycle

// state machine vars
int currentState   = 0;  // current state for state machine
int nextState      = 0;  // state to jump to

/**
 * Calculate the number of steps required to travel a given distance
 */
int calcSteps(int mm)
{
  return (mm / DIST_PER_REV) * STEPS_PER_REV;
}

/**
 * Get the distance from the distance knob, but round it
 */
int getDistance()
{
  int roundedDist = analogRead(KNOB_DIST) / (1023/DIST_INCR);
  return map( roundedDist, 0, DIST_INCR, 0, DIST_MAX);
}

/**
 * Get the pause time from the pause time knob, but round it
 */
int getPauseTime()
{
  int roundedPause = analogRead(KNOB_PAUSE) / (1023/PAUSE_INCR);
  return map( roundedPause, 0, PAUSE_INCR, 0, PAUSE_MAX);
}

/**
 * get the state of the direction switch, if reverse or fwds is high, then run
 * should be high. if both are low, then run should be false
 */
bool getRun()
{
  if( digitalRead(SW_DIR_FWD) || digitalRead(SW_DIR_REV))
    run = true;
  else
    run = false;

  return run;
}

bool getDir()
{
  if(digitalRead(SW_DIR_FWD))
    fwd = true;

  if(digitalRead(SW_DIR_REV))
    fwd = false;

  return fwd;
}

void drawSpeed()
{
  String strOut = "SPEED: ";
  char buf[] ="";

  strOut += (fwd)? 0xaf : 0xae;
  strOut += ' ';

  for(int i=0; i< (analogRead(KNOB_SPEED)+1)/204; i++)
    strOut += 0xdb;

  strOut.toCharArray(buf,sizeof(strOut));

  LcdString(buf);
}

void drawDistance()
{
  String strOut = " DIST: ";
  char buf[] ="";

  if(distance < 1000)
    strOut += " ";

  if(distance <  100)
    strOut += " ";

  if(distance <   10)
    strOut += " ";

  strOut += distance + " mm  ";

  strOut.toCharArray(buf,sizeof(strOut));

  LcdString(buf);
}

void drawPause()
{
  String strOut = "PAUSE: ";
  char buf[] ="";

  if(pauseTime < 1000)
    strOut += " ";

  if(pauseTime <  100)
    strOut += " ";

  if(pauseTime <   10)
    strOut += " ";

  strOut += pauseTime + " s   ";

  strOut.toCharArray(buf,sizeof(strOut));

  LcdString(buf);
}

void drawBoxTop()
{
  char buf[] = "╔══════════════╗";
  LcdString(buf);
}
void drawBoxBottom()
{
  char buf[] = "╚══════════════╝";
  LcdString(buf);
}

void drawChooching()
{
  char buf[] = "║  CHOOCHING!  ║";
  LcdString(buf);
}

void drawStart()
{
  char buf[] = "║ PRESS  START ║";
  LcdString(buf);
}

void drawPauses()
{
  String strOut = "║ PAUSED: ";
  char buf[] ="";

  if(remainingTime < 100)
    strOut += " ";

  if(remainingTime <  10)
    strOut += " ";

  strOut += remainingTime + " s║";

  strOut.toCharArray(buf,sizeof(strOut));

  LcdString(buf);
}

void drawInit1()
{
  byte bitmap[] =
  {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x03, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x03, 0xfe, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0xdf, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x06, 0xff, 0xff, 0x00, 0x7f, 0xff,
    0xff, 0xf0, 0x00, 0x00, 0x0e, 0x7b, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x92, 0x49, 0x31,
    0xef, 0xff, 0xfc, 0x49, 0x27, 0xff, 0xff, 0xf0, 0x00, 0x04, 0xe7, 0xdf, 0xfe, 0x00, 0x00, 0x07,
    0xf7, 0xff, 0xf0, 0x24, 0x93, 0x1f, 0x3f, 0xff, 0x49, 0x24, 0x9f, 0xa3, 0xff, 0xf0, 0x00, 0x00,
    0xfe, 0xff, 0xff, 0x80, 0x00, 0x2e, 0xc3, 0xff, 0xf0, 0xaa, 0x83, 0xfb, 0xff, 0xff, 0xe5, 0x41,
    0xee, 0xc7, 0xfe, 0xd0, 0x00, 0x07, 0xd7, 0xff, 0xc7, 0xf0, 0x07, 0xff, 0xef, 0x80, 0x00, 0x54,
    0x06, 0xaf, 0xfc, 0xeb, 0xfb, 0x3e, 0x6e, 0xff, 0xa9, 0x50, 0x00, 0x05, 0xff, 0xf8, 0x60, 0x70,
    0x3f, 0xef, 0xfe, 0x12, 0x00, 0xa0, 0x0b, 0xff, 0xf1, 0x0a, 0x06, 0x9e, 0xff, 0xfd, 0x49, 0x60,
    0x00, 0x03, 0xff, 0xca, 0x44, 0x21, 0x00, 0x1f, 0x78, 0x92, 0x00, 0x80, 0x07, 0x7f, 0xc5, 0x32,
    0x9a, 0x6e, 0x8e, 0x72, 0x49, 0xb0, 0x00, 0x8a, 0xff, 0x92, 0x95, 0x45, 0x10, 0x51, 0x09, 0x54,
    0x40, 0x00, 0x17, 0xff, 0x2c, 0xa4, 0xb2, 0xd5, 0x54, 0xd4, 0xab, 0x20, 0x02, 0x43, 0xfc, 0x52,
    0x1a, 0x4c, 0x4a, 0xa6, 0x4b, 0x49, 0x50, 0x20, 0x3f, 0xfe, 0xaa, 0xd3, 0x66, 0xb5, 0x32, 0xb4,
    0xac, 0xa0, 0x13, 0xdf, 0xff, 0x54, 0x0c, 0x99, 0x4a, 0xcd, 0x4b, 0x53, 0x50, 0xdc, 0xff, 0xfe,
    0x23, 0xf1, 0x66, 0xd9, 0x32, 0xb4, 0xac, 0xa0, 0x6f, 0x7f, 0xfe, 0xff, 0xfe, 0x5a, 0x57, 0xad,
    0xab, 0x57, 0x70, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xad, 0xb2, 0x6a, 0xd6, 0xb2, 0x90, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xaa, 0xdd, 0xb6, 0xb5, 0xb6, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb6, 0xab,
    0x5b, 0x5b, 0x5b, 0x50, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x5b, 0x76, 0xea, 0xed, 0xb5, 0xb0, 0xff,
    0xff, 0xff, 0xfa, 0x57, 0x6d, 0xad, 0x5d, 0xb6, 0xdb, 0x60, 0xff, 0xff, 0xff, 0x4d, 0xfb, 0x6e,
    0xf7, 0xee, 0xdb, 0x6e, 0xd0, 0xff, 0xff, 0xfb, 0xbe, 0xad, 0xdb, 0x5a, 0xb7, 0x77, 0xbb, 0xe0,
    0xff, 0xff, 0xae, 0xeb, 0xff, 0x7d, 0xff, 0xdf, 0xbe, 0xed, 0x70, 0xd8, 0x0a, 0xc3, 0x80, 0x01,
    0xc3, 0x60, 0xc3, 0xd0, 0x3f, 0xb0, 0x78, 0x07, 0xc3, 0x00, 0x00, 0xc2, 0xc1, 0xc3, 0x60, 0x16,
    0xf0, 0xe8, 0x03, 0xc3, 0x00, 0x00, 0xc3, 0x83, 0xc3, 0xe0, 0x1f, 0xd0, 0x78, 0x01, 0x43, 0x0f,
    0xf0, 0xc3, 0x06, 0xc3, 0x43, 0x0b, 0x70, 0xf8, 0x40, 0xc3, 0x0f, 0xf0, 0xc2, 0x0f, 0xc3, 0xc3,
    0x0f, 0xf0, 0x78, 0x60, 0x43, 0x0f, 0xd0, 0xc0, 0x1f, 0xc3, 0x87, 0x87, 0xf0, 0xf8, 0x70, 0x03,
    0x0e, 0xf0, 0xc2, 0x0e, 0xc3, 0x80, 0x07, 0xb0, 0xe8, 0x78, 0x03, 0x0f, 0xf0, 0xc3, 0x07, 0xc3,
    0x00, 0x03, 0xf0, 0xf8, 0x7c, 0x03, 0x00, 0x00, 0xc3, 0x83, 0xc3, 0x00, 0x03, 0xf0, 0xf8, 0x7e,
    0x03, 0x00, 0x00, 0xc3, 0xc1, 0xc2, 0x1f, 0xe1, 0xf0, 0xf8, 0x7f, 0x03, 0x80, 0x01, 0xc3, 0xe0,
    0xc2, 0x1f, 0xe1, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  };

  for(unsigned int i=0; i < sizeof(bitmap); i++)
    LcdWrite(LCD_D, bitmap[i]);
}

void drawInit2()
{
  byte bitmap[] =
  {
    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x78, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x08, 0xce, 0x66, 0xce, 0x00,
    0x00, 0x00, 0x70, 0x70, 0x00, 0x00, 0x0c, 0xdb, 0x6c, 0xdb, 0x00, 0x00, 0x00, 0x70, 0x70, 0x00,
    0x00, 0x0e, 0xdb, 0x78, 0xdb, 0x00, 0x00, 0x00, 0x70, 0x70, 0x00, 0x00, 0x0f, 0xdb, 0x70, 0xdb,
    0x00, 0x00, 0x00, 0x70, 0x70, 0x00, 0x00, 0x0d, 0xdb, 0x78, 0xdf, 0x00, 0x00, 0x00, 0x70, 0x70,
    0x00, 0x00, 0x0c, 0xdb, 0x6c, 0xdb, 0x00, 0x00, 0x00, 0x70, 0x70, 0x00, 0x00, 0x0c, 0x4e, 0x66,
    0xdb, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x73, 0x9e, 0x6c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf6, 0xdb, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0xb7, 0xdb, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x36, 0x1b,
    0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x33, 0xdb, 0x3c, 0x00, 0x00, 0x00, 0x00,
  };

  for(unsigned int i=0; i < sizeof(bitmap); i++)
    LcdWrite(LCD_D, bitmap[i]);
}

void drawPanic()
{
  char buf[] ="";
  drawBoxTop();

  strcpy(buf, "║              ║");
  LcdString(buf);

  strcpy(buf, "║    PANIC!    ║");
  LcdString(buf);

  strcpy(buf,"║      :(      ║");
  LcdString(buf);

  strcpy(buf,"║              ║");
  LcdString(buf);

  drawBoxBottom();
}

/**
 * Wrapper for Stepper.step(int) because it is blocking and won't
 * allow use of limit switches (well maybe an ISR could be used?)
 */
void chooch()
{
  if( remainingSteps >= 1 && !digitalRead(SW_LIMIT) )
  {
    motor.step(10);
    remainingSteps -= 10;
  }

  // prevent remainingSteps from being less than 0
  if(remainingSteps < 0)
    remainingSteps = 0;

  // if limit switch is hit, update state machine to go to [STATE_DATA]
  if(digitalRead(SW_LIMIT))
    nextState = STATE_DATA;
  else
    nextState = STATE_PAUSE;
}

/**
 * Wrapper for delay(int). Also permit limit switches to break the cycle.
 */
void pause()
{
  if( remainingTime >= 1 && !digitalRead(SW_LIMIT) )
  {
    delay(1000);
    remainingTime--;
  }

  // prevent remainingTime from being less than 0
  if(remainingTime < 0)
    remainingTime = 0;

  // if limit switch is hit, update state machine to go to [read data]
  if(digitalRead(SW_LIMIT))
    nextState = STATE_DATA;
  else
    nextState = STATE_RUN;
}
void setup()
{
  LcdInitialise();
  LcdClear();
}

void loop()
{
  /* State machine:
   *  [STATE_INIT] -> [STATE_DATA] -> [STATE_RUN] <-> [STATE_PAUSE]
   *
   * If a limit switch is hit in [STATE_RUN] or [STATE_PAUSE], then next state
   * is set to [STATE_DATA].
   */
  switch(nextState)
  {
    LcdClear();

    case STATE_INIT:
      nextState = STATE_DATA;

      drawInit1();
      delay(5000);

      drawInit2();
      delay(2000);
    break;

    case STATE_DATA:
      distance = getDistance();
      pauseTime = getPauseTime();
      remainingSteps = calcSteps(distance);

      drawSpeed();
      drawPause();
      drawDistance();
      drawBoxTop();

      drawStart();

      drawBoxBottom();
    break;

    case STATE_RUN:
      drawSpeed();
      drawPause();
      drawDistance();
      drawBoxTop();

      drawChooching();

      drawBoxBottom();

      chooch(); // chooch is blocking
    break;

    case STATE_PAUSE:
      drawSpeed();
      drawPause();
      drawDistance();
      drawBoxTop();

      drawPauses();

      drawBoxBottom();
      pause(); // pause is blocking (contains delay())
    break;

    default:
      // we shouldn't ever get to this point. enter AvE mode.
      // panic. call for help.
      drawPanic();
      delay(INT_MAX);
    break;
  }
}
